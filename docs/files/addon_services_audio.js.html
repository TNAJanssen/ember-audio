<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>addon/services/audio.js - ember-audio</title>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min-ecd4a5d6c0cbee10b168f6aa000c64ea.css" integrity="sha256-HS1ihgXZ6qfUcS5BTehJhV81EZR+I5Q6zx5yGdEqbp0= sha512-T23C9FH3sSw+W00kbZbvWt8h/P1h8Euj3cklmPSZNeyGekNivnCvp7KKIFju5D3blaYVmVaD0oAjbS2c+J+huQ==" >
    <link rel="stylesheet" href="../assets/css/main-81a744c27cc7449efcd5a4308805a56f.css" id="site_styles" integrity="sha256-lmgfQjoLLIO5EO5HRKPt2FejDbtTPO0BGKxn1tqReMI= sha512-55xJjT5gmMB4vtNd+yN+XbPJaSBciawgt9pR/SJDaGxAkJBdaMIazBHi7qKjfs+3F5ZmI6yXztfpcTPyujc6Hg==" >
    <script src="http://yui.yahooapis.com/combo?3.8.0pr2/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div class="yui3-g">
        <div id="sidebar" class="yui3-u">
            <div class="logo">
              <a href="../index.html">
                  ember-audio
              </a>
            </div>
            
            <div id="modules" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Modules</h2>
                </div>
                <div class="bd">
                    <ul>
                            <li><a href="../modules/Audio.html">Audio</a>
                            </li>
                            <li><a href="../modules/AudioHelpers.html">AudioHelpers</a>
                            </li>
                            <li><a href="../modules/AudioService.html">AudioService</a>
                            </li>
                            <li><a href="../modules/MusicalConcepts.html">MusicalConcepts</a>
                            </li>
                            <li><a href="../modules/utils.html">utils</a>
                            </li>
                    </ul>
                </div>
            </div>
            
            <div id="classes" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Classes</h2>
                </div>
                <div class="bd">
                    <ul>
                            <li><a href="../classes/AudioService.html">AudioService</a></li>
                            <li><a href="../classes/Beat.html">Beat</a></li>
                            <li><a href="../classes/BeatTrack.html">BeatTrack</a></li>
                            <li><a href="../classes/Connectable.html">Connectable</a></li>
                            <li><a href="../classes/Connection.html">Connection</a></li>
                            <li><a href="../classes/Font.html">Font</a></li>
                            <li><a href="../classes/LayeredSound.html">LayeredSound</a></li>
                            <li><a href="../classes/MusicalIdentity.html">MusicalIdentity</a></li>
                            <li><a href="../classes/Note.html">Note</a></li>
                            <li><a href="../classes/Oscillator.html">Oscillator</a></li>
                            <li><a href="../classes/Playable.html">Playable</a></li>
                            <li><a href="../classes/SampledNote.html">SampledNote</a></li>
                            <li><a href="../classes/Sampler.html">Sampler</a></li>
                            <li><a href="../classes/Sound.html">Sound</a></li>
                            <li><a href="../classes/Track.html">Track</a></li>
                            <li><a href="../classes/utils.html">utils</a></li>
                    </ul>
                </div>
            </div>
            
            
            
            
            
            <div class="version-info">
              Version: 0.0.0-alpha.1.957e43f3
            </div>
            
        </div>

        <div id="main" class="yui3-u">
            <div class="content"><div class="title">
  <h1 class="file-name">addon/services/audio.js</h1>
</div>

<pre class="code prettyprint linenums">
import Ember from &#x27;ember&#x27;;
import fetch from &#x27;ember-network/fetch&#x27;;
import { Sound, Note, SampledNote, Track, BeatTrack, Sampler, Oscillator, Font } from &#x27;ember-audio&#x27;;
import { sortNotes, base64ToUint8, mungeSoundFont, frequencyMap } from &#x27;ember-audio/utils&#x27;;

/**
 * Provides the Audio Service
 *
 * @public
 * @module AudioService
 */

const {
  RSVP: { all, resolve },
  Error: EmberError,
  Logger,
  Service
} = Ember;

/**
 * A {{#crossLink &quot;Ember.Service&quot;}}Service{{/crossLink}} that provides methods
 * for interacting with the various
 * {{#crossLinkModule &quot;Audio&quot;}}{{/crossLinkModule}} classes and the Web Audio
 * API&#x27;s {{#crossLink &quot;AudioContext&quot;}}{{/crossLink}}. This can be thought of as
 * the &quot;entrypoint&quot; to using ember-audio. An application using ember-audio
 * should use this service for all interactions with the Web Audio API.
 *
 *     Ember.Something.extend({
 *       audio: Ember.inject.service(),
 *
 *       loadSound() {
 *         return this.get(&#x27;audio&#x27;).load(&#x27;some.mp3&#x27;).asSound(&#x27;some-sound&#x27;);
 *       }
 *     });
 *
 *
 * @public
 * @class AudioService
 *
 * @todo consider creating a class called something like EmberAudioLoadResponse
 * to use in place of current POJO returned from load().
 *
 * @todo consider removing concept of &quot;registers&quot;. They only exist at the moment
 * for their caching behavior. Might want to let users decide what is cached
 * for memory reasons? A long running app (like a game), might end up with lots
 * of sounds.
 */
export default Service.extend({
  /**
   * An AudioContext instance from the Web Audio API. **NOT** available in all
   * browsers. Not available in any version of IE (except EDGE)
   * as of April 2016.
   *
   * @public
   * @property audioContext
   * @type {AudioContext}
   * @todo change this to audioContext to match other stuff, or change other stuff to audioContext
   */
  audioContext: new AudioContext(),

  /**
   * This acts as a register for Sound instances. Sound instances are placed in
   * the register by name, and can be called via audioService.getSound(&#x27;name&#x27;)
   *
   * @private
   * @property _sounds
   * @type {map}
   */
  _sounds: new Map(),

  /**
   * This acts as a register for Sampler instances. Sampler instances are placed
   * in the register by name, and can be called via audioService.getSampler(&#x27;name&#x27;)
   *
   * @private
   * @property _samplers
   * @type {map}
   */
  _samplers: new Map(),

  /**
   * This acts as a register for soundfonts. A font is just a &#x60;Map&#x60; of Note
   * objects which is placed in this register by name, and can be played like:
   * &#x60;audioService.getFont(&#x27;some-font&#x27;).play(&#x27;Ab1&#x27;);&#x60;
   *
   * @private
   * @property _fonts
   * @type {map}
   */
  _fonts: new Map(),

  /**
   * This acts as a register for Track instances. Track instances are placed in
   * this register by name, and can be called via audioService.getTrack(&#x27;name&#x27;)
   *
   * @private
   * @property _tracks
   * @type {map}
   */
  _tracks: new Map(),

  /**
   * This acts as a register for BeatTrack instances. BeatTrack instances are
   * placed in the register by name, and can be called via
   * audioService.getBeatTrack(&#x27;name&#x27;)
   *
   * @private
   * @property _beatTracks
   * @type {map}
   */
  _beatTracks: new Map(),

  /**
   * Acts as a proxy method, returns a POJO with methods that return the _load
   * and _loadFont methods so that in the end. See example.
   *
   * @example
   *     audio.load(&#x27;some-url.wav&#x27;).asSound(&#x27;some-sound&#x27;);
   *     audio.load(&#x27;some-url.mp3&#x27;).asTrack(&#x27;some-track&#x27;);
   *     audio.load([&#x27;some-url.mp3&#x27;]).asSampler(&#x27;some-sampler&#x27;);
   *     audio.load([&#x27;some-url.mp3&#x27;]).asBeatTrack(&#x27;some-beat-track&#x27;);
   *     audio.load(&#x27;some-url.js&#x27;).asFont(&#x27;some-font&#x27;);
   *
   * @public
   * @method load
   *
   * @param {string|array} src The URL location of an audio file. Will be used by
   * &quot;fetch&quot; to get the audio file. Can be a local or a relative URL. An array
   * of URLs is required if a beatTrack is being loaded via &#x60;.asBeatTrack&#x60; or
   * &#x60;.asSampler&#x60;.
   *
   * @return {object} returns a POJO that contains a few methods that curry
   * &quot;src&quot; &quot;type&quot; and &quot;name&quot; over to
   * {{#crossLink &quot;Audio/_load:method&quot;}}{{/crossLink}} and
   * {{#crossLink &quot;Audio/_loadFont:method&quot;}}{{/crossLink}} and allow you to
   * specify what type of Sound you&#x27;d like created.
   *
   * @todo find a better way than returning a POJO
   */
  load(src) {
    const audioContext = this.get(&#x27;audioContext&#x27;);
    const _load = this._load.bind(this);
    const _loadFont = this._loadFont.bind(this);
    const _loadBeatTrack = this._loadBeatTrack.bind(this);
    const _createSoundsArray = this._createSoundsArray.bind(this);
    const samplersRegister = this.get(&#x27;_samplers&#x27;);
    const { createNoteArray } = this;

    return {
      /*
       * Creates a Sound instance from a src URL.
       *
       * @param {string} name The name that this Sound instance will be
       * registered as in the &quot;_sounds&quot; register.
       *
       * @return {promise|Sound} Returns a promise that resolves to a Sound
       * instance. The promise resolves when the Sound instance&#x27;s AudioBuffer
       * (audio data) is finished loading.
       */
      asSound(name) {
        return _load(name, src, &#x27;sound&#x27;);
      },

      /*
       * Creates a Track instance from a src URL.
       *
       * @param {string} name The name that this Track instance will be
       * registered as in the &quot;_tracks&quot; register.
       *
       * @return {promise|Track} Returns a promise that resolves to a Track
       * instance. The promise resolves when the Track instance&#x27;s AudioBuffer
       * (audio data) is finished loading.
       */
      asTrack(name) {
        return _load(name, src, &#x27;track&#x27;);
      },

      /*
       * Creates a BeatTrack instance from an array of src URLs.
       *
       * @param {string} name The name that this BeatTrack instance will be
       * registered as in the &quot;_beatTracks&quot; register
       *
       * @return {promise|Track} Returns a promise that resolves to a BeatTrack
       * instance. The promise resolves when the BeatTrack instance&#x27;s AudioBuffer
       * (audio data) is finished loading.
       */
      asBeatTrack(name) {
        return _loadBeatTrack(name, src);
      },

      /*
       * Creates a font instance from a src URL.
       *
       * @param {string} name The name that this font will be registered as in
       * the &quot;_fonts&quot; register.
       *
       * @return {promise|array} Returns a promise that resolves to an Array of
       * sorted note names. The promise resolves when the soundfont file is
       * finished loading and it&#x27;s audio data has been successfully decoded.
       */
      asFont(name) {
        return _loadFont(name, src);
      },

      /*
       * Creates a Sampler instance from an array of src URLs.
       *
       * @param {string} name The name that this Sampler instance will be
       * registered as in the _samplers register
       *
       * @return {promise|Sampler} Returns a promise that resolves to a Sampler
       * instance. The promise resolves when all the Sound instances loaded into
       * the Sampler instance are finished loading.
       */
      asSampler(name) {
        return _createSoundsArray(name, src).then((soundsArray) =&gt; {
          const sounds = new Set(soundsArray);
          const sampler = Sampler.create({ sounds, audioContext, name });

          samplersRegister.set(name, sampler);

          return sampler;
        });
      },

      /*
       * Creates an array of note instances from a JSON file.
       *
       * @param {string} name The name that this Sampler instance will be
       * registered as in the _samplers register
       *
       * @return {promise|array|Note} Returns a promise that resolves to an array
       * of Note instances.
       */
      asNoteArray() {
        return fetch(src)
          .then((response) =&gt; response.json())
          .then(createNoteArray);
      }
    };
  },

  /**
   * Creates an array of Note objects from a json object containing notes and
   * frequency values.
   *
   * @public
   * @method createNoteArray
   *
   * @param {object|null} json Optionally provided json object. If not provided,
   * the object returned from utils/frequencyMap is used.
   *
   * @return {array|Note}
   * @todo allow createNoteArray to accept array of note names with no frequencies
   */
  createNoteArray(json) {
    const notes = [];

    if (!json) {
      json = frequencyMap;
    }

    for (let noteName in json) {
      notes.push(Note.create({ frequency: json[noteName] }));
    }

    return notes;
  },

  /**
   * Creates a Sound instance with it&#x27;s audioBuffer filled with one sample&#x27;s
   * worth of white noise.
   *
   * @public
   * @method createWhiteNoise
   *
   * @param {object} opts An object passed into the Sound instance.
   *
   * @return {Sound} The created white noise Sound instance.
   */
  createWhiteNoise(opts={}) {
    const audioContext = this.get(&#x27;audioContext&#x27;);
    const bufferSize = audioContext.sampleRate;
    const audioBuffer = audioContext.createBuffer(1, bufferSize, bufferSize);
    const output = audioBuffer.getChannelData(0);

    for (let i = 0; i &lt; bufferSize; i++) {
      output[i] = Math.random() * 2 - 1;
    }

    return Sound.create(Object.assign(opts, { audioContext, audioBuffer }));
  },

  /**
   * Creates an Oscillator instance.
   *
   * @public
   * @method createOscillator
   *
   * @param {object} opts An object passed into the Oscillator instance.
   *
   * @return {Oscillator} The created Oscillator instance.
   */
  createOscillator(opts={}) {
    const audioContext = this.get(&#x27;audioContext&#x27;);
    return Oscillator.create(Object.assign(opts, { audioContext }));
  },

  /**
   * Gets a BeatTrack instance by name from the _beatTracks register.
   *
   * @public
   * @method getBeatTrack
   * @param {string} name The name of the BeatTrack instance that should be
   * retrieved from the _beatTracks register.
   *
   * @return {BeatTrack} Returns the BeatTrack instance that matches the
   * provided name.
   */
  getBeatTrack(name) {
    return this.get(&#x27;_beatTracks&#x27;).get(name);
  },

  /**
   * Gets a Sound instance by name from the _sounds register
   *
   * @public
   * @method getSound
   *
   * @param {string} name The name of the sound that should be retrieved
   * from the _sounds register.
   *
   * @return {Sound} returns the Sound instance that matches the provided name.
   */
  getSound(name) {
    return this.get(&#x27;_sounds&#x27;).get(name);
  },

  /**
   * Gets a Track instance by name from the _tracks register
   *
   * @public
   * @method getTrack
   *
   * @param {string} name The name of the Track instance that should be
   * retrieved from the _tracks register.
   *
   * @return {Track} Returns the Track instance that matches the provided name.
   */
  getTrack(name) {
    return this.get(&#x27;_tracks&#x27;).get(name);
  },

  /**
   * Gets a soundfont Map by name from the _fonts register and allows it to be
   * played via the returned POJO containing a method called &#x60;play&#x60;.
   *
   * @example
   *     audio.getFont(&#x27;some-font&#x27;).play(&#x27;Ab1&#x27;);
   *
   * @public
   * @method getFont
   *
   * @param {string} name The name of the Map that should be retrieved
   * from the _fonts register.
   *
   * @return {object} Returns a POJO that has a &#x60;play&#x60; method which allows a
   * note from the requested font to be played.
   */
  getFont(name) {
    return this.get(&#x27;_fonts&#x27;).get(name);
  },

  /**
   * Gets a Sampler instance by name from the _samplers register
   *
   * @public
   * @method getSampler
   *
   * @param {string} name The name of the sampler that should be retrieved
   * from the _samplers register.
   *
   * @return {Sampler} returns the Sampler instance that matches the provided name.
   */
  getSampler(name) {
    return this.get(&#x27;_samplers&#x27;).get(name);
  },

  /**
  * Gets all instances of requested type and calls
  * {{#crossLink &quot;Sound/stop:method&quot;}}{{/crossLink}} on each.
   *
   * @public
   * @method stopAll
   *
   * @param {string} type=&#x27;tracks&#x27; The type of the register that you wish
   * to stop all instances of. Can be &#x60;&#x27;tracks&#x27;&#x60;, or &#x60;&#x27;sounds&#x27;&#x60;.
   */
  stopAll(type=&#x27;tracks&#x27;) {
    for (let sound of this.get(&#x60;_${type}&#x60;).values()) {
      sound.stop();
    }
  },

  /**
   * Gets all Track instances and calls
   * {{#crossLink &quot;Sound/pause:method&quot;}}{{/crossLink}} on each. Only works for
   * tracks because only Track instances are pause-able.
   *
   * @public
   * @method pauseAll
   */
  pauseAll() {
    for (let sound of this.get(&#x27;_tracks&#x27;).values()) {
      sound.pause();
    }
  },

  /**
   * Given a sound&#x27;s name and type, removes the sound from it&#x27;s register.
   *
   * @public
   * @method removeFromRegister
   *
   * @param {string} type The type of sound that should be removed. Can be
   * &#x27;sound&#x27;, &#x27;track&#x27;, &#x27;font&#x27;, &#x27;beatTrack&#x27;, or &#x27;sampler&#x27;.
   *
   * @param {string} name The name of the sound that should be removed.
   */
  removeFromRegister(type, name) {
    const register = this._getRegisterFor(type);
    register.set(name, null);
  },

  /**
   * Gets a register by it&#x27;s type.
   *
   * @private
   * @method _getRegisterFor
   * @param {string} type Which register to return.
   * @return {map}
   */
  _getRegisterFor(type) {
    switch (type) {
      case &#x27;sound&#x27;:
        return this.get(&#x27;_sounds&#x27;);
      case &#x27;track&#x27;:
        return this.get(&#x27;_tracks&#x27;);
      case &#x27;beatTrack&#x27;:
        return this.get(&#x27;_beatTracks&#x27;);
      case &#x27;sampler&#x27;:
        return this.get(&#x27;_samplers&#x27;);
      case &#x27;font&#x27;:
        return this.get(&#x27;_fonts&#x27;);
    }
  },

  /**
   * Creates an {{#crossLinkModule &quot;Audio&quot;}}Audio Class{{/crossLinkModule}}
   * instance (which is based on which &quot;type&quot; is specified), and passes &quot;props&quot;
   * to the new instance.
   *
   * @private
   * @method _createSoundFor
   *
   * @param {string} type The type of
   * {{#crossLinkModule &quot;Audio&quot;}}Audio Class{{/crossLinkModule}} to be created.
   *
   * @param {object} props POJO to pass to the new instance
   *
   * @return {Sound|Track|BeatTrack}
   */
  _createSoundFor(type, props) {
    switch (type) {
      case &#x27;track&#x27;:
        return Track.create(props);
      case &#x27;beatTrack&#x27;:
        return BeatTrack.create(props);
      case &#x27;sampler&#x27;:
        return Sampler.create(props);
      default:
        return Sound.create(props);
    }
  },

  /**
   * Loads and decodes an audio file, creating a Sound, Track, or BeatTrack
   * instance (as determined by the &quot;type&quot; parameter) and places the instance
   * into it&#x27;s corresponding register.
   *
   * @private
   * @method _load
   *
   * @param {string} name The name that the created instance should be
   * registered as.
   *
   * @param {string} src The URI location of an audio file. Will be used by
   * &quot;fetch&quot; to get the audio file. Can be a local or a relative URL
   *
   * @param {string} type Determines the type of object that should be created,
   * as well as which register the instance should be placed in. Can be &#x27;sound&#x27;,
   * &#x27;track&#x27;, or &#x27;beatTrack&#x27;.
   *
   * @return {promise|Sound|Track|BeatTrack} Returns a promise which resolves
   * to an instance of a Sound, Track, or BeatTrack
   */
  _load(name, src, type) {
    const audioContext = this.get(&#x27;audioContext&#x27;);
    const register = this._getRegisterFor(type);

    if (register.has(name)) {
      return resolve(register.get(name));
    }

    return fetch(src)
      .then((response) =&gt; response.arrayBuffer())
      .then((arrayBuffer) =&gt; audioContext.decodeAudioData(arrayBuffer))
      .then((audioBuffer) =&gt; {
        const sound = this._createSoundFor(type, { audioBuffer, audioContext, name });
        register.set(name, sound);
        return sound;
      })
      .catch((err) =&gt; {
        console.error(&#x27;ember-audio:&#x27;, err);
        console.error(&#x27;ember-audio:&#x27;, &#x27;This error was probably caused by a 404 or an incompatible audio file type&#x27;);
      });
  },

  /**
   * 1. Creates a Font instance and places it in the fonts register.
   * 2. Loads a soundfont file and decodes all the notes.
   * 3. Creates a Note instance for each note.
   * 4. Places each note on the font, using the note&#x27;s identifier as key.
   * 5. Returns a promise that resolves to an array of properly sorted Note
   * object instances.
   *
   * The notes are sorted the way that they would appear on a piano. In the
   * example, you can see how the note &#x60;Ab1&#x60; from the &#x60;font-name&#x60; soundfont
   * would be played:
   *
   * @example
   *     audio.getFont(&#x27;font-name&#x27;).play(&#x27;Ab1&#x27;);
   *
   * @private
   * @method _loadFont
   *
   * @param {string} instrumentName The name that you will refer to this sound
   * font by.
   *
   * @param {string} src The URI location of a soundfont file. Will be used by
   * &quot;fetch&quot; to get the soundfont file. Can be a local or a relative URL.
   *
   * @return {promise|array} Returns a promise that resolves when the sound font
   * has been successfully decoded. The promise resolves to an array of sorted note names.
   */
  _loadFont(instrumentName, src) {
    const fontsRegister = this._getRegisterFor(&#x27;font&#x27;);

    // If the font already exists, no need to load it up again.
    if (fontsRegister.has(instrumentName)) {
      const err = new EmberError(&#x60;ember-audio: You tried to load a soundfont instrument called &quot;${name}&quot;, but it already exists. Repeatedly loading the same soundfont all willy-nilly is unnecessary and would have a negative impact on performance, so the previously loaded instrument has been cached and will be reused unless you explicitly remove it with &quot;audioService.removeFromRegister(&#x27;font&#x27;, &#x27;${instrumentName}&#x27;)&quot;&#x60;);

      Logger.error(err);

      return resolve(fontsRegister.get(instrumentName));
    }

    // Create a Font instance and place it in the _fonts register
    fontsRegister.set(instrumentName, Font.create());

    return fetch(src).then((response) =&gt; response.text())

      // Strip extraneous stuff from soundfont (which is currently a long string)
      // and split by line into an array
      .then(mungeSoundFont)

      // Decode base64 to audio data, splitting each line from the sound font
      // into a key and value like, [noteName, decodedAudio]
      .then((audioData) =&gt; this._extractDecodedKeyValuePairs(audioData))

      // Create a Note instance for each note from the decoded audio data.
      // Also sets the note on the corresponding font in the _fonts register.
      .then((keyValuePairs) =&gt; this._createNoteObjectsForFont(keyValuePairs, instrumentName))

      .catch((err) =&gt; console.error(&#x27;ember-audio:&#x27;, err));
  },

  /**
   * Creates a BeatTrack instance from an array of URLs.
   *
   * @private
   * @method _loadBeatTrack
   *
   * @param {string} name The name that this BeatTrack instance will be
   * registered as on the _beatTracks register.
   *
   * @param {array} srcArray An array of strings that specify URLs to load as
   * Sounds.
   *
   * @return {Promise|BeatTrack} A promise that resolves to a BeatTrack instance.
   */
  _loadBeatTrack(name, srcArray) {
    const audioContext = this.get(&#x27;audioContext&#x27;);

    return this._createSoundsArray(name, srcArray).then((soundsArray) =&gt; {
      const sounds = new Set(soundsArray);
      return BeatTrack.create({ sounds, audioContext, name });
    });
  },

  /**
   * Accepts an array of URLs to audio files and creates a Sound instance for
   * each.
   *
   * @private
   * @method _createSoundsArray
   *
   * @param {string} name The base-name of the sound. If one were loading up
   * multiple kick drum samples, this might be &#x27;kick&#x27;.
   *
   * @param {array} srcArray An array of strings. Each item being a URL to an
   * audio file that should be loaded and turned into a Sound instance.
   *
   * @return {Promise|array} A promise that resolves to an array of Sound objects.
   */
  _createSoundsArray(name, srcArray) {
    const sounds = srcArray.map((src, idx) =&gt; {
      return this._load(&#x60;${name}${idx}&#x60;, src, &#x27;sound&#x27;);
    });

    return all(sounds);
  },

  /**
   * Takes an array of base64 encoded strings (notes) and returns an array of
   * arrays like [[name, audio], [name, audio]]
   *
   * @private
   * @method _extractDecodedKeyValuePairs
   * @param {array} notes Array of base64 encoded strings.
   * @return {array} Returns an Array of arrays. Each inner array has two
   * values, &#x60;[noteName, decodedAudio]&#x60;.
   */
  _extractDecodedKeyValuePairs(notes) {
    const ctx = this.get(&#x27;audioContext&#x27;);
    const promises = [];

    function decodeNote(noteName, buffer) {
      // Get web audio api audio data from array buffer
      return ctx.decodeAudioData(buffer)

      // Set promise value to array with note name and decoded note data
      .then((decodedNote) =&gt; [noteName, decodedNote]);
    }

    for (let noteName in notes) {
      if (notes.hasOwnProperty(noteName)) {

        // Transform base64 note value to Uint8Array
        const noteValue = base64ToUint8(notes[noteName]);

        promises.push(decodeNote(noteName, noteValue.buffer));
      }
    }

    // Wait for array of promises to resolve before continuing
    return all(promises);
  },

  /**
   * Takes an array of arrays, each inner array acting as
   * a key-value pair in the form &#x60;[noteName, audioData]&#x60;. Each inner array is
   * transformed into a {{#crossLink &quot;Note&quot;}}{{/crossLink}} and the outer array
   * is returned. This method also sets each note on it&#x27;s corresponding
   * instrument {{#crossLink &quot;Map&quot;}}{{/crossLink}} instance by name. Each note
   * is playable as seen in the example.
   *
   * @example
   *     audioService.getFont(&#x27;font-name&#x27;).play(&#x27;Ab5&#x27;);
   *
   * @private
   * @method _createNoteObjectsForFont
   *
   * @param {array} audioData Array of arrays, each inner array like
   * &#x60;[noteName, audioData]&#x60;.
   *
   * @param {string} instrumentName Name of the instrument each note belongs to.
   * This is the name that will be used to identify the instrument on the fonts
   * register.
   *
   * @return {array} Returns an Array of {{#crossLink &quot;Note&quot;}}Notes{{/crossLink}}
   */
  _createNoteObjectsForFont(audioData, instrumentName) {
    const audioContext = this.get(&#x27;audioContext&#x27;);
    const fontsRegister = this._getRegisterFor(&#x27;font&#x27;);
    const font = fontsRegister.get(instrumentName);

    const notes = audioData.map((note) =&gt; {
      const [ identifier, audioBuffer ] = note;
      return SampledNote.create({
        identifier,
        audioBuffer,
        audioContext
      });
    });

    font.set(&#x27;notes&#x27;, sortNotes(notes));

    return font;
  }
});

</pre>

</div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min-8dcb0650a8bd6a247abff6765e43040d.js" integrity="sha256-diihLR0asHHxFN+NqoV4qpSvexH85SSJukuSkTxrcEA= sha512-zTGRkp/yAiVPNmxPJ7k2NnZe7aR2xXeAGDNaQnFTbvTARElf+UXMiDydPtR3n7LVZkqioLtxhkY9funHfhIp5A==" ></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify-da760a61cb717e2aa0032f496f9d95d0.js" integrity="sha256-OceGphJyxBL0QHqDhUPIAqInTT4yDCdKiwPM5cM2Di8= sha512-mHOjxDVAmJtGveeZiOlcpSIj62TLFkwhtokv51d+96obX359cFYd+xdbC3Q6bCSid1EkfbzQIORLCe3MIqT/+Q==" ></script>
</body>
</html>
